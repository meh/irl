#! /usr/bin/env ruby
# Copyleft meh. [http://meh.doesntexist.org | meh.ffff@gmail.com]
#
# irl is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# irl is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with irl. If not, see <http://www.gnu.org/licenses/>.

require 'thread'
require 'getoptlong'
require 'ncursesw'
require 'failirc/client'

$version = '0.0.1'

args = GetoptLong.new(
    ['--version', '-v', GetoptLong::NO_ARGUMENT],
    ['--config', '-f', GetoptLong::REQUIRED_ARGUMENT]
)

options = {
    :config => "#{ENV['HOME']}/.irl/config",
}

args.each {|option, value|
    case option

    when '--version'
        puts "irl #{$version}"
        exit 0

    when '--config'
        options[:config] = value
    end
}

class UI
    class Window
        class Buffer
            attr_reader   :data
            attr_accessor :position

            def initialize
                @data     = []
                @position = 0
            end
        end

        def initialize (window)
            @window = window
            self.focused = false
        end

        def puts (string, refresh=true)
            @window.addstr "#{string}\n"

            if refresh
                self.refresh
            end
        end

        def focused?
            @focused
        end

        def focused= (value)
            @focused = value

            if value
                @window.clear
                @window.mvaddstr(0, 0, self.buffer(@window.getmaxy))
                self.refresh
            end
        end

        def buffer (lines)
            @buffer
        end

        def refresh
            @window.refresh
        end
    end

    class Input
        attr_reader   :window
        attr_accessor :utf8

        @@symbols = {
            :ALT       => 27,
            :BACKSPACE => 127,

            :ARROWS => {
                :UP   => { :SHIFT => 527 },
                :DOWN => { :SHIFT => 513 },
            },
        }

        def initialize (window)
            @window = window
            @utf8   = true

            @window.keypad true
        end

        def readChar
            result = {
                :ALT   => false,
                :CTRL  => false,
                :SHIFT => false,
                :value => nil,
            }

            value = @window.getch

            if value == @@symbols[:ALT]
                result[:ALT] = true

                value = @window.getch
            end

            if value <= 26
                if value == 10
                    value = :ENTER
                elsif value == 9
                    value = :TAB
                else
                    result[:CTRL] = true
                    value += 64
                end
            end

            case value

            when Ncurses::KEY_ENTER, :ENTER
                result[:value] = :ENTER

            when :TAB
                result[:value] = :TAB

            when Ncurses::KEY_LEFT, Ncurses::KEY_SLEFT
                if value == Ncurses::KEY_SLEFT
                    result[:SHIFT] = true
                end

                result[:value] = :LEFT

            when Ncurses::KEY_UP, @@symbols[:ARROWS][:UP][:SHIFT]
                if value == @@symbols[:ARROWS][:UP][:SHIFT]
                    result[:SHIFT] = true
                end

                result[:value] = :UP

            when Ncurses::KEY_DOWN, @@symbols[:ARROWS][:DOWN][:SHIFT]
                if value == @@symbols[:ARROWS][:UP][:SHIFT]
                    result[:SHIFT] = true
                end

                result[:value] = :DOWN

            when Ncurses::KEY_RIGHT, Ncurses::KEY_SRIGHT
                if value == Ncurses::KEY_SRIGHT
                    result[:SHIFT] = true
                end

                result[:value] = :RIGHT

            when Ncurses::KEY_BACKSPACE, @@symbols[:BACKSPACE]
                result[:value] = :BACKSPACE

            when Ncurses::KEY_HOME, Ncurses::KEY_SHOME
                if value == Ncurses::KEY_SHOME
                    result[:SHIFT] = true
                end

                result[:value] = :HOME

            when Ncurses::KEY_END, Ncurses::KEY_SEND
                if value == Ncurses::KEY_SEND
                    result[:SHIFT] = true
                end

                result[:value] = :END

            when Ncurses::KEY_NPAGE
                result[:value] = :PAGDOWN

            when Ncurses::KEY_PPAGE
                result[:value] = :PAGUP

            when Ncurses::KEY_DC
                result[:value] = :CANC

            else
                begin
                    result[:value] = String.new
                    result[:value].force_encoding('ASCII-8BIT')

                    if self.utf8
                        case Input.bin(value)

                        when /^0/
                            result[:value].concat(value)

                        when /^110/
                            result[:value].concat(value)
                            result[:value].concat(@window.getch)

                        when /^1110/
                            result[:value].concat(value)
                            result[:value].concat(@window.getch)
                            result[:value].concat(@window.getch)

                        when /^11110/
                            result[:value].concat(value)
                            result[:value].concat(@window.getch)
                            result[:value].concat(@window.getch)
                            result[:value].concat(@window.getch)

                        end

                        result[:value].force_encoding('UTF-8')
                    else
                        result[:value].concat(value)
                    end
                rescue
                    result[:value] = nil
                end
            end

            return result
        end

        def readLine
            self.readChar
        end

        def put (value)
            @window.addstr value
            @window.refresh
        end

        def self.bin (n)
            [n].pack('C').unpack('B8')[0]
        end
    end

    attr_reader   :client, :raw, :input, :windows
    attr_accessor :focused

    def initialize (client)
        @client = client

        @raw = {
            :input  => Ncurses::WINDOW.new(1, Ncurses.COLS, Ncurses.COLS - 1, 0),
            :output => Ncurses::WINDOW.new(Ncurses.LINES - 1, Ncurses.COLS, 0, 0),
        }

        @input = Input.new(@raw[:input])

        @windows = []
        self.focused = @windows.push(Window.new(@raw[:output])).last
    end

    def finalize
    end

    def start
        loop do
            char = @input.readLine

            if char[:value] == 'q'
                Process.exit! 0
            else
                puts "#{char[:CTRL] ? 'CTRL ' : ''}#{char[:ALT] ? 'ALT ' : ''}#{char[:SHIFT] ? 'SHIFT ' : ''}#{char[:value]}"
            end
        end
    end

    def puts (*args)
        self.focused.puts *args
    end
end

class Config
    def initialize (path)
        @doc = Document.new File.new path
    end

    def toClient
        result = {}
    end
end

$Config = Config.new(options[:config])
$Client = IRC::Client.new $Config.toClient, false

begin
    Ncurses.initscr
    Ncurses.raw    # provide unbuffered input
    Ncurses.noecho # turn off input echoing
    Ncurses.nonl   # turn off newline translation
    
    Ncurses.stdscr.intrflush false # turn off flush-on-interrupt
    Ncurses.stdscr.keypad true     # turn on keypad mode     

    $UI = UI.new($Client)
    $UI.start
rescue Exception => e
    $error = e
ensure
    Ncurses.echo
    Ncurses.noraw
    Ncurses.nl
    Ncurses.endwin

    $stderr.puts "#{$error.class}: #{$error.message}\n\n"
    $stderr.puts $error.backtrace.collect {|stack|
        "#{stack}"
    }.join("\n")

end
