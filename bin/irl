#! /usr/bin/env ruby
# Copyleft meh. [http://meh.doesntexist.org | meh.ffff@gmail.com]
#
# irl is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# irl is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with irl. If not, see <http://www.gnu.org/licenses/>.

require 'thread'
require 'getoptlong'
require 'ncursesw'
require 'failirc/client'

$version = '0.0.1'

args = GetoptLong.new(
    ['--version', '-v', GetoptLong::NO_ARGUMENT],
    ['--config', '-f', GetoptLong::REQUIRED_ARGUMENT]
)

options = {
    :config => "#{ENV['HOME']}/.irl/config",
}

args.each {|option, value|
    case option

    when '--version'
        puts "irl #{$version}"
        exit 0

    when '--config'
        options[:config] = value
    end
}

class UI
    class Window
        class Buffer
            attr_reader   :data
            attr_accessor :position

            def initialize
                @data     = []
                @position = 0
            end
        end

        def initialize (window)
            @window = window
            self.focused = false
        end

        def puts (string, refresh=true)
            @window.addstr "#{string}\n"

            if refresh
                self.refresh
            end
        end

        def focused?
            @focused
        end

        def focused= (value)
            @focused = value

            if value
                @window.clear
                @window.mvaddstr(0, 0, self.buffer(@window.getmaxy))
                self.refresh
            end
        end

        def buffer (lines)
            @buffer
        end

        def refresh
            @window.refresh
        end
    end

    class Input
        attr_reader   :window
        attr_accessor :utf8

        def initialize (window)
            @window = window
            @utf8   = true
        end

        def readchar
            result = {
                :ALT   => false,
                :CTRL  => false,
                :SHIFT => false,
                :value => String.new,
            }

            result[:value].force_encoding('ASCII-8BIT')

            value = @window.getch

            if value == 27
                result[:ALT] = :LEFT

                value = @window.getch
            end

            if value
                if self.utf8
                    case Input.bin(value)

                    when /^0/
                        result[:value].concat(value)

                    when /^110/
                        result[:value].concat(value)
                        result[:value].concat(@window.getch)

                    when /^1110/
                        result[:value].concat(value)
                        result[:value].concat(@window.getch)
                        result[:value].concat(@window.getch)

                    when /^11110/
                        result[:value].concat(value)
                        result[:value].concat(@window.getch)
                        result[:value].concat(@window.getch)
                        result[:value].concat(@window.getch)

                    end

                    result[:value].force_encoding('UTF-8')
                else
                    result[:value].concat(value)
                end
            else
                result[:value] = nil
            end

            return result
        end

        def readline
            self.readchar
        end

        def self.bin (n)
            [n].pack('C').unpack('B8')[0]
        end
    end

    attr_reader   :client, :raw, :input, :windows
    attr_accessor :focused

    def initialize (client)
        @client = client

        @raw = {
            :input  => Ncurses::WINDOW.new(1, Ncurses.COLS, Ncurses.COLS - 1, 0),
            :output => Ncurses::WINDOW.new(Ncurses.LINES - 1, Ncurses.COLS, 0, 0),
        }

        @input = Input.new(@raw[:input])

        @windows = []
        self.focused = @windows.push(Window.new(@raw[:output])).last
    end

    def finalize
    end

    def start
        loop do
            char = @input.readchar

            if char[:value] == 'q'
                Process.exit! 0
            else
                puts "#{char[:ALT] ? "ALT-#{char[:ALT].to_s} " : ''}#{char[:value]}"
            end
        end
    end

    def puts (*args)
        self.focused.puts *args
    end
end

class Config
    def initialize (path)
        @doc = Document.new File.new path
    end

    def toClient
        result = {}
    end
end

$Config = Config.new(options[:config])
$Client = IRC::Client.new $Config.toClient, false

begin
    Ncurses.initscr
    Ncurses.raw    # provide unbuffered input
    Ncurses.noecho # turn off input echoing
    Ncurses.nonl   # turn off newline translation
    
    Ncurses.stdscr.intrflush false # turn off flush-on-interrupt
    Ncurses.stdscr.keypad true     # turn on keypad mode     

    $UI = UI.new($Client)
    $UI.start
rescue Exception => e
    $error = e
ensure
    Ncurses.echo
    Ncurses.noraw
    Ncurses.nl
    Ncurses.endwin

    $stderr.puts "#{$error.class}: #{$error.message}\n\n"
    $stderr.puts $error.backtrace.collect {|stack|
        "#{stack}"
    }.join("\n")

end
